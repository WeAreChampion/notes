#include<iostream>
#include<cmath>
#define MAX_SIZE 100
using namespace std;
/**
	1> 假设有n = 2^k个运动员，要进行网球循环赛，设计一个满足以下要求的比赛日程表
	1. 每个选手必须与其他n-1个选手各赛一次
	2. 每个选手一天只能赛一次
	3. 循环赛一共进行n-1天
	
	2> 按此情况，将比赛日程表设计成有n行和n-1列的表，在表中第i行和第j列出填入第i个选手在第j
	天所遇到的选手。
	
	3> 按分治策略，可以将所有对手对分成两半，n个选手的比赛日程表就可以通过n/2个选手设计的日
	程表来觉得。递归地使用这种一分为二的策略对选手进行分割，直到剩下两个选手时，就只要让
	这两个选手比赛即可。
	
	4> 左上角与左下角的两小块分别为选手1-选手4和选手5-选手8前三天的比赛日程
	   将左上角的数字抄到右下角，左下角的数字抄到右上角，这样就安排好了。
	   
	5> 
	|------------------------|
	|1 | 2  3  4 | 5  6  7  8|
	|2 | 1  4  3 | 6  5  8  7|
	|3 | 4  1  2 | 7  8  5  6|
	|4 | 3  2  1 | 8  7  6  5|
	|------------------------|
	|5 | 6  7  8 | 1  2  3  4|
	|6 | 5  8  7 | 2  1  4  3|
	|7 | 8  5  6 | 3  4  1  2|
	|8 | 7  6  5 | 4  3  2  1|
	|------------------------|

*/
void table(int k, int array[MAX_SIZE][MAX_SIZE], int n)
{
	int i, j;

	// 自己的编号
	for(i = 1; i <= n; i++) {
		array[1][i] = i;
	}

	// m = 1,代表小矩阵的长度、宽度
	int m = 1;
	
	// 循环次数
	for(int s = 1; s <= k; s++) {
		// 对半分割
		n = n / 2;
		
		// 共有n个运动员
		for(int t = 1; t <= n; t++) {
			
			// 遍历一个小矩阵，m为小矩阵的长度、宽度，i->行
			for(i = m + 1; i <= 2 * m; i++) {
				
				// 遍历一个小矩阵，m为小矩阵的长度、宽度，j->列
				for(j = m + 1; j <= 2 * m; j++) {
					// 左下角 = 右上角
					array[i][j + (t - 1) * m * 2] = array[i - m][j + (t - 1) * m * 2 - m];
					
					// 左上角 = 右下角
					array[i][j + (t - 1) * m * 2 - m] = array[i - m][j + (t - 1) * m * 2];
				}
			}
		}
		
		// 小矩阵的长度、宽度以2的倍数扩展
		m = m * 2;
	}
}
void testTable()
{
	int k;
	while(cin >> k) {
		int array[MAX_SIZE][MAX_SIZE];

		int n = 1;
		for(int i = 1; i <= k; i++) {
			n *= 2;
		}
		
		cout << "n = " << n << endl;
		table(k, array, n);

		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				cout << array[i][j] << "  ";
			}
			cout << endl;
		}
	}
}
int main()
{
	testTable();
	return 0;
}
/**
Input:
3


Output:
1  2  3  4  5  6  7  8
2  1  4  3  6  5  8  7
3  4  1  2  7  8  5  6
4  3  2  1  8  7  6  5
5  6  7  8  1  2  3  4
6  5  8  7  2  1  4  3
7  8  5  6  3  4  1  2
8  7  6  5  4  3  2  1
*/